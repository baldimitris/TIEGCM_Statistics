<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TIEGCM_Statistics.Plotter_AltProfComparison API documentation</title>
<meta name="description" content="Creates altitude profiles plots of the median of two datasets in order to compare them.
Reads two data structures with results of statistical â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TIEGCM_Statistics.Plotter_AltProfComparison</code></h1>
</header>
<section id="section-intro">
<p>Creates altitude profiles plots of the median of two datasets in order to compare them.
Reads two data structures with results of statistical calculations and creates an altitude profiles plot where the two datasets are plotted together.<br>
It creates one subfigure per Magnetic Local Time - Kp index combination.<br>
Each subfigure contains the two altitude profiles of the 50th percentile (median) of each dataset.<br>
In case the second dataset is not provided it automatically reads the data from the Tromso EISCAT radar.<br>
X axis represents the variable studied and Y axis represents the altitude.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Creates altitude profiles plots of the median of two datasets in order to compare them.
Reads two data structures with results of statistical calculations and creates an altitude profiles plot where the two datasets are plotted together.  
It creates one subfigure per Magnetic Local Time - Kp index combination.  
Each subfigure contains the two altitude profiles of the 50th percentile (median) of each dataset.  
In case the second dataset is not provided it automatically reads the data from the Tromso EISCAT radar.  
X axis represents the variable studied and Y axis represents the altitude.
&#34;&#34;&#34;

import Data as D

import numpy as np
import plotly
import chart_studio.plotly as py 
import plotly.graph_objects as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
import scipy.io
import scipy
import math

def plotAltProf_MedianComparison( VariableName, Buckets, CurveColor=&#34;dodgerblue&#34;, Buckets2=None, CurveColor2=&#34;dodgerblue&#34;, SuperTitle=&#34;&#34; ):
    &#39;&#39;&#39;
    Creates comparison plots of two data sets.  
    The median values of each dataset are plotted together as altitude profiles for each MLT-Kp bin.
    In case the second dataset (Buckets2) is None, then the function reads data produced by the Tromso EISCAT radar.
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        Buckets (dictionary): The data structure which contains the statistical calculation results of the 1st dataset. See the function Data.init_ResultDataStructure() for details.
        CurveColor (string): The 1st dataset will be plotted with this color.
        Buckets2 (dictionary): The data structure which contains the statistical calculation results of the 2nd dataset. See the function Data.init_ResultDataStructure() for details.
        CurveColor2 (string): The 2nd dataset will be plotted with this color.
        SuperTitle (string): This title will be displayed at the top of the plot.
    &#39;&#39;&#39;
    HEIGHT_INTEGRATED_RATIO_ALL_average = 0
    HEIGHT_INTEGRATED_RATIO_UPPER_average = 0
    HEIGHT_INTEGRATED_RATIO_LOWER_average = 0
    TIEGCMarea_Upper = 0
    TIEGCMarea_Lower = 0
    TIEGCMarea2_Upper = 0
    TIEGCMarea2_Lower = 0
    EISCATcolor = CurveColor2 
    print(&#34;------------------ TIEGCM info start ------------------\n&#34;)
    print( &#34;ALT_distance_of_a_bucket:&#34;, D.ALT_distance_of_a_bucket )
    print( &#34;ALTsequence:&#34;, D.ALTsequence )
    print(&#34;------------------ TIEGCM info finish ------------------\n\n&#34;)
    
    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName:
        if Buckets2 != None:
            x_axes_range=[0, 3]
        else:
            x_axes_range=[0, 20]
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    elif VariableName == &#34;Pedersen Conductivity&#34;:
        x_axes_range=[0, 0.4]
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        x_axes_range=[0, 10]
        MultiplicationFactor = 1
        new_units = &#34;?&#34;

    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = D.ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += D.ALT_distance_of_a_bucket/2
    visibleALTsequence[0] = D.ALTsequence[0]
    visibleALTsequence[-1] = D.ALTsequence[-1] + D.ALT_distance_of_a_bucket
    
    # construct the column MLT titles #(&#34;0-3&#34;, &#34;3-6&#34;, &#34;6-9&#34;, &#34;9-12&#34;, &#34;12-15&#34;, &#34;15-18&#34;, &#34;18-21&#34;, &#34;21-24&#34;)
    ColumnTitles = list()
    
    for i in range(0, len(D.MLTsequence)):
        MLTfrom = int(D.MLTsequence[i])
        if MLTfrom &gt; 24: MLTfrom -=24
        MLTto = int(D.MLTsequence[i]+D.MLT_duration_of_a_bucket)
        if MLTto &gt; 24: MLTto -=24
        ColumnTitles.append( &#34;MLT &#34; + str(MLTfrom) + &#34;-&#34;  + str(MLTto) )
    # define secondary y-axis at the right of the plot
    mySpecs = list()
    for row in range(0, len(D.KPsequence)):
        mySpecs.append( list() )
        for col in range(0, len(D.MLTsequence)):
            mySpecs[row].append( {&#34;secondary_y&#34;: True} )

    #make plot
    if VariableName == &#34;Joule Heating&#34;: 
        XXtitle = &#39;Joule heating (10&lt;sup&gt;-8&lt;/sup&gt; W/m&lt;sup&gt;3&lt;/sup&gt;)&#39;
    elif VariableName == &#34;Pedersen Conductivity&#34;:
        XXtitle = &#39;Pedersen conductivity (mS/m)&#39;
    else:
        XXtitle = VariableName
    fig = make_subplots(rows=len(D.KPsequence), cols=len(D.MLTsequence), x_title=XXtitle, shared_xaxes=True, shared_yaxes=True, vertical_spacing=0.035, horizontal_spacing=0.02, subplot_titles=ColumnTitles, specs=mySpecs)
    
    fig.update_layout( font=dict( family=&#34;arial black&#34;, size=24 ) )
    fig.update_annotations( font=dict( family=&#34;arial black&#34;, size=24) )
    #fig.update_xaxes(title_font_family=&#34;Arial black&#34;, title_font_size=20)
    #fig.update_yaxes(title_font_family=&#34;Arial black&#34;, title_font_size=20)
    fig.update_xaxes(tickfont_size=22)
    fig.update_yaxes(tickfont_size=22)
    fig.layout.annotations[4][&#34;font&#34;] = {&#39;size&#39;: 30}  # this is the XXtitle at the bottom
    
    for aKP in D.KPsequence:
        for aMLT in D.MLTsequence:
            #Means = list()
            TIEGCMmedian = list()
            TIEGCMmedian2 = list()
            hits  = 0

            # compute TIEGCM 2ND RESULT percentiles
            if Buckets2 != None:
                TIEGCMarea_Upper = 0
                TIEGCMarea_Lower = 0
                TIEGCMarea2_Upper = 0
                TIEGCMarea2_Lower = 0
    
                for anALT in D.ALTsequence:
                    TIEGCMmedian2.append( Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor )
                #
                for anALT in D.ALTsequence:
                    if anALT &gt;= 120:
                        TIEGCMarea2_Upper += Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                    else:
                        TIEGCMarea2_Lower += Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                # plot TIEGCM 2ND RESULT median
                if CurveColor==CurveColor2:
                    linetype = &#39;dot&#39;
                else:
                    linetype = &#39;solid&#39;
                fig.add_trace( go.Scatter(x=TIEGCMmedian2, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=None, line=dict(color=CurveColor,width=4,dash=linetype,), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1 )
                # CALCULATE the Height_integration-Vaue for TIEGCM 2ND RESULT= area under median curve
                TIEGCMarea2 = 0
                for i in range(0, len(TIEGCMmedian2)):
                    if math.isnan(TIEGCMmedian2[i]) == False: 
                        TIEGCMarea2 += TIEGCMmedian2[i]*D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;

            # compute TIEGCM percentiles
            for anALT in D.ALTsequence:
                TIEGCMmedian.append( Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor )
            #
            for anALT in D.ALTsequence:
                if anALT &gt;= 120:
                    TIEGCMarea_Upper += Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                else:
                    TIEGCMarea_Lower += Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
            # plot TIEGCM median
            fig.add_trace( go.Scatter(x=TIEGCMmedian, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=None, line=dict(color=CurveColor,width=4,), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1 )
            
            # CALCULATE the Height_integration-Vaue for TIEGCM = area under median curve
            TIEGCMarea = 0
            for i in range(0, len(TIEGCMmedian)):
                if math.isnan(TIEGCMmedian[i]) == False: 
                    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName: 
                        TIEGCMarea += TIEGCMmedian[i]*D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                    elif VariableName == &#34;Pedersen Conductivity&#34;:
                        TIEGCMarea += TIEGCMmedian[i]*D.ALT_distance_of_a_bucket # area*1000 * math.pow(10,-8) * 1000;

            # read the median curve of EISCAT
            [EISCATmedian, EISCATmedianTHIN] = getEISCAT_MedianCurve(VariableName, aKP, aMLT)
            
            # CALCULATE the Height_integration-Vaue for EISCAT = area under median curve
            EISCATarea = 0.0
            for i in range(0, len(EISCATmedian)):
                if math.isnan(EISCATmedian[i]) == False: 
                    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName: 
                        EISCATarea += EISCATmedian[i]*0.01  #area += EISCATmedian[i]*1000 * math.pow(10,-8) * 1000;
                    elif VariableName == &#34;Pedersen Conductivity&#34;:
                        EISCATarea += EISCATmedian[i]

            # Calculate the Percentage Difference
            try:
                SimilarityFactor_eiscat = (TIEGCMarea-EISCATarea) / ((TIEGCMarea+EISCATarea)/2)
                SimilarityFactor_eiscat = int(round(100*SimilarityFactor_eiscat,   0)) # %
            except:
                SimilarityFactor_eiscat = 0
            if Buckets2 != None:
                try:
                    SimilarityFactor_winds =  (TIEGCMarea2-TIEGCMarea) / TIEGCMarea 
                    SimilarityFactor_winds = int(round(100*SimilarityFactor_winds, 0)) # %    
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_ALL&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea/TIEGCMarea2,2) )
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_UPPER&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea_Upper/TIEGCMarea2_Upper ,2) )
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_LOWER&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea_Lower/TIEGCMarea2_Lower ,2) )
                    HEIGHT_INTEGRATED_RATIO_ALL_average += TIEGCMarea/TIEGCMarea2
                    HEIGHT_INTEGRATED_RATIO_UPPER_average += TIEGCMarea_Upper/TIEGCMarea2_Upper
                    HEIGHT_INTEGRATED_RATIO_LOWER_average += TIEGCMarea_Lower/TIEGCMarea2_Lower
                except:
                    pass
                #
                
            
                
            sim_factor_color = &#34;purple&#34;    

            # add annotations
            if VariableName==&#34;Joule Heating&#34;:
                if Buckets2 != None:
                    fig.add_annotation(xref=&#39;x domain&#39;, yref=&#39;y domain&#39;, x=0.99, y=1, text=F&#34;&lt;b&gt;{SimilarityFactor_winds}%&lt;/b&gt;&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=CurveColor) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=1, text=F&#34;{round(TIEGCMarea_Upper/TIEGCMarea2_Upper,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=0.5, text=F&#34;{round(TIEGCMarea/TIEGCMarea2,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=0, text=F&#34;{round(TIEGCMarea_Lower/TIEGCMarea2_Lower,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                
                
            # add a trace in order to display secondary y-axis at the right
            fig.add_trace( go.Scatter(x=[-1000], y=[-1000], line=dict(color=CurveColor,width=1), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, secondary_y=True )
            
            
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    
    print ( &#34;HEIGHT_INTEGRATED_RATIO_ALL&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_ALL_average/12 ,2) )
    print ( &#34;HEIGHT_INTEGRATED_RATIO_UPPER&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_UPPER_average/12 ,2) )
    print ( &#34;HEIGHT_INTEGRATED_RATIO_LOWER&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_LOWER_average/12 ,2) )
    
    fig.update_xaxes( range=x_axes_range, row=1, col=1)
    fig.update_xaxes( range=x_axes_range, row=1, col=2)
    fig.update_xaxes( range=x_axes_range, row=1, col=3)
    fig.update_xaxes( range=x_axes_range, row=1, col=4)
    
    fig.update_xaxes( range=x_axes_range, row=2, col=1)
    fig.update_xaxes( range=x_axes_range, row=2, col=2)
    fig.update_xaxes( range=x_axes_range, row=2, col=3)
    fig.update_xaxes( range=x_axes_range, row=2, col=4)
    
    fig.update_xaxes( range=x_axes_range, row=3, col=1)
    fig.update_xaxes( range=x_axes_range, row=3, col=2)
    fig.update_xaxes( range=x_axes_range, row=3, col=3)
    fig.update_xaxes( range=x_axes_range, row=3, col=4)
    
    for aKP in D.KPsequence:
        fig.update_yaxes( title_text=&#34;Altitude(km)&#34;, row=D.KPsequence.index(aKP)+1, col=1, side=&#39;left&#39;, secondary_y=False)
        row_title = &#34;Kp &#34; + str(aKP) + &#34; - &#34;
        if aKP == 0:
            row_title +=  &#34;2&#34;
        elif aKP == 2:
            row_title +=  &#34;4&#34;
        else:
            row_title +=  &#34;9&#34;
        fig.update_yaxes( title_text=row_title, row=D.KPsequence.index(aKP)+1, col=len(D.MLTsequence),  side=&#39;right&#39;, secondary_y=True, showticklabels=False )
        for aMLT in D.MLTsequence:
            fig.update_yaxes( row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, secondary_y=True, showticklabels=False )
    #fig.update_xaxes( range=x_axes_range )
    fig.update_yaxes( range=[80, 150], tick0=90, dtick=20 )  
    fig.update_layout( title = SuperTitle,
                       width=400+len(D.MLTsequence)*250, height=200+200*len(D.KPsequence), showlegend=False, legend_orientation=&#34;h&#34;, legend_y=-0.04) 

    if Buckets2 == None:
        plotEISCAT( VariableName, fig )
    
    plotly.offline.init_notebook_mode(connected=True)
    plotly.offline.iplot(fig) 

    # plot more zoom versions
    &#39;&#39;&#39;
    new_x_axes_range = [x * (2/3) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (1/2) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (3/2) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (2.5) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (10) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    &#39;&#39;&#39;

    
    
    

def getEISCAT_MedianCurve( VariableName, aKP, aMLT ):
    &#39;&#39;&#39;
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        aKP (float): A Kp index value (0-9)
        aMLT (float): A Magnetic Local Time value 
    Returns:
        A list of points representing an altitude profile median curve for the desired KP and MLT combination
    &#39;&#39;&#39;
    if aMLT &gt; 24: aMLT -= 24
    
    Values = None
    matlabStruct = scipy.io.loadmat(&#39;./EISCAT_DATA/data_2009_2019_TS.mat&#39;)
    
    allALTs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][0] ).flatten()
    allKPs  = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][1][0] ) )
    allMLTs = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][2][0] )[:-1] )
    allJHs  = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][3] )
    allPEDs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][4] )
    
    if VariableName == &#34;Pedersen Conductivity&#34;:
        Values = allPEDs
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        Values = allJHs
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    
    ALTsequence =  allALTs
    MLTsequence = allMLTs
    KPsequence = [ 0, 2, 4 ]
    MLT_duration_of_a_profile = 6
    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += 0.5
    
    MedianCurve = Values[KPsequence.index(aKP), MLTsequence.index(aMLT), :, 2] * MultiplicationFactor
    
    #print( &#34;~~~~~~~~~~~~Thinning EISCAT median to compare with TIEGCM median&#34;, len(ALTsequence) )
    EISCATmedianTHIN = []
    for i in range( 0, len(MedianCurve) ):
        if ALTsequence[i] in D.ALTsequence:
            EISCATmedianTHIN.append( MedianCurve[i] )
    
    return [ MedianCurve, EISCATmedianTHIN ]

    

def plotEISCAT( VariableName, fig ):
    &#39;&#39;&#39;
    Adds altitude profile curves of the median value of a variable as calculated by EISCAT
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        fig (plotly object): the plotly figure upon which the EISCAT altitude profiles of the median value will be plotted.
    &#39;&#39;&#39;
    EISCATcolor = &#34;limegreen&#34;
    
    matlabStruct = scipy.io.loadmat(&#39;./EISCAT_DATA/data_2009_2019_TS.mat&#39;)
    
    allALTs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][0] ).flatten()
    allKPs  = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][1][0] ) )
    allMLTs = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][2][0] )[:-1] )
    allJHs  = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][3] )
    allPEDs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][4] )
    
    print(&#34;------------------ EISCAT info start ------------------&#34;)
    print( &#34;Altitudes:&#34;, allALTs[0], allALTs[1], &#34;...&#34;, allALTs[-1] )
    print( &#34;KPs:&#34;, allKPs  )
    print( &#34;MLTs:&#34;, allMLTs )
    print( &#34;JHs shape:&#34;, allJHs.shape )
    print( &#34;PEDs shape:&#34;, allPEDs.shape )    
    print(&#34;------------------ EISCAT info finish ------------------\n\n&#34;)
    
    if VariableName == &#34;Pedersen Conductivity&#34;:
        Values = allPEDs
        x_axes_range=[0, 0.4]
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        Values = allJHs
        x_axes_range=[0, 20]
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    
    ALTsequence =  allALTs
    MLTsequence = allMLTs
    KPsequence = [ 0, 2, 4 ]  #list( mat_medians[ &#39;jouleMedians&#39; ][0][0][3] )
    MLT_duration_of_a_profile = 6
    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += 0.5
    
    for aKP in KPsequence:
        for aMLT in MLTsequence:
            #Means = list()
            EISCATmedian = list()            
            hits  = 0
            
            # compute percentiles
            EISCATmedian = Values[KPsequence.index(aKP), MLTsequence.index(aMLT), :, 2] * MultiplicationFactor #EISCATmedian = JHmedians[1,1,:] * MultiplicationFactor 

            fig.add_trace( go.Scatter(x=EISCATmedian, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=EISCATcolor, line=dict(color=EISCATcolor,width=4,), showlegend=False), row=KPsequence.index(aKP)+1, col=MLTsequence.index(aMLT)+1 )
            
      </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="TIEGCM_Statistics.Plotter_AltProfComparison.getEISCAT_MedianCurve"><code class="name flex">
<span>def <span class="ident">getEISCAT_MedianCurve</span></span>(<span>VariableName, aKP, aMLT)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>VariableName</code></strong> :&ensp;<code>string</code></dt>
<dd>The physical variable on which the calculation has been applied. </dd>
<dt><strong><code>aKP</code></strong> :&ensp;<code>float</code></dt>
<dd>A Kp index value (0-9)</dd>
<dt><strong><code>aMLT</code></strong> :&ensp;<code>float</code></dt>
<dd>A Magnetic Local Time value </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of points representing an altitude profile median curve for the desired KP and MLT combination</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEISCAT_MedianCurve( VariableName, aKP, aMLT ):
    &#39;&#39;&#39;
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        aKP (float): A Kp index value (0-9)
        aMLT (float): A Magnetic Local Time value 
    Returns:
        A list of points representing an altitude profile median curve for the desired KP and MLT combination
    &#39;&#39;&#39;
    if aMLT &gt; 24: aMLT -= 24
    
    Values = None
    matlabStruct = scipy.io.loadmat(&#39;./EISCAT_DATA/data_2009_2019_TS.mat&#39;)
    
    allALTs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][0] ).flatten()
    allKPs  = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][1][0] ) )
    allMLTs = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][2][0] )[:-1] )
    allJHs  = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][3] )
    allPEDs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][4] )
    
    if VariableName == &#34;Pedersen Conductivity&#34;:
        Values = allPEDs
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        Values = allJHs
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    
    ALTsequence =  allALTs
    MLTsequence = allMLTs
    KPsequence = [ 0, 2, 4 ]
    MLT_duration_of_a_profile = 6
    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += 0.5
    
    MedianCurve = Values[KPsequence.index(aKP), MLTsequence.index(aMLT), :, 2] * MultiplicationFactor
    
    #print( &#34;~~~~~~~~~~~~Thinning EISCAT median to compare with TIEGCM median&#34;, len(ALTsequence) )
    EISCATmedianTHIN = []
    for i in range( 0, len(MedianCurve) ):
        if ALTsequence[i] in D.ALTsequence:
            EISCATmedianTHIN.append( MedianCurve[i] )
    
    return [ MedianCurve, EISCATmedianTHIN ]</code></pre>
</details>
</dd>
<dt id="TIEGCM_Statistics.Plotter_AltProfComparison.plotAltProf_MedianComparison"><code class="name flex">
<span>def <span class="ident">plotAltProf_MedianComparison</span></span>(<span>VariableName, Buckets, CurveColor='dodgerblue', Buckets2=None, CurveColor2='dodgerblue', SuperTitle='')</span>
</code></dt>
<dd>
<div class="desc"><p>Creates comparison plots of two data sets.<br>
The median values of each dataset are plotted together as altitude profiles for each MLT-Kp bin.
In case the second dataset (Buckets2) is None, then the function reads data produced by the Tromso EISCAT radar.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>VariableName</code></strong> :&ensp;<code>string</code></dt>
<dd>The physical variable on which the calculation has been applied. </dd>
<dt><strong><code>Buckets</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>The data structure which contains the statistical calculation results of the 1st dataset. See the function Data.init_ResultDataStructure() for details.</dd>
<dt><strong><code>CurveColor</code></strong> :&ensp;<code>string</code></dt>
<dd>The 1st dataset will be plotted with this color.</dd>
<dt><strong><code>Buckets2</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>The data structure which contains the statistical calculation results of the 2nd dataset. See the function Data.init_ResultDataStructure() for details.</dd>
<dt><strong><code>CurveColor2</code></strong> :&ensp;<code>string</code></dt>
<dd>The 2nd dataset will be plotted with this color.</dd>
<dt><strong><code>SuperTitle</code></strong> :&ensp;<code>string</code></dt>
<dd>This title will be displayed at the top of the plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotAltProf_MedianComparison( VariableName, Buckets, CurveColor=&#34;dodgerblue&#34;, Buckets2=None, CurveColor2=&#34;dodgerblue&#34;, SuperTitle=&#34;&#34; ):
    &#39;&#39;&#39;
    Creates comparison plots of two data sets.  
    The median values of each dataset are plotted together as altitude profiles for each MLT-Kp bin.
    In case the second dataset (Buckets2) is None, then the function reads data produced by the Tromso EISCAT radar.
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        Buckets (dictionary): The data structure which contains the statistical calculation results of the 1st dataset. See the function Data.init_ResultDataStructure() for details.
        CurveColor (string): The 1st dataset will be plotted with this color.
        Buckets2 (dictionary): The data structure which contains the statistical calculation results of the 2nd dataset. See the function Data.init_ResultDataStructure() for details.
        CurveColor2 (string): The 2nd dataset will be plotted with this color.
        SuperTitle (string): This title will be displayed at the top of the plot.
    &#39;&#39;&#39;
    HEIGHT_INTEGRATED_RATIO_ALL_average = 0
    HEIGHT_INTEGRATED_RATIO_UPPER_average = 0
    HEIGHT_INTEGRATED_RATIO_LOWER_average = 0
    TIEGCMarea_Upper = 0
    TIEGCMarea_Lower = 0
    TIEGCMarea2_Upper = 0
    TIEGCMarea2_Lower = 0
    EISCATcolor = CurveColor2 
    print(&#34;------------------ TIEGCM info start ------------------\n&#34;)
    print( &#34;ALT_distance_of_a_bucket:&#34;, D.ALT_distance_of_a_bucket )
    print( &#34;ALTsequence:&#34;, D.ALTsequence )
    print(&#34;------------------ TIEGCM info finish ------------------\n\n&#34;)
    
    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName:
        if Buckets2 != None:
            x_axes_range=[0, 3]
        else:
            x_axes_range=[0, 20]
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    elif VariableName == &#34;Pedersen Conductivity&#34;:
        x_axes_range=[0, 0.4]
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        x_axes_range=[0, 10]
        MultiplicationFactor = 1
        new_units = &#34;?&#34;

    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = D.ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += D.ALT_distance_of_a_bucket/2
    visibleALTsequence[0] = D.ALTsequence[0]
    visibleALTsequence[-1] = D.ALTsequence[-1] + D.ALT_distance_of_a_bucket
    
    # construct the column MLT titles #(&#34;0-3&#34;, &#34;3-6&#34;, &#34;6-9&#34;, &#34;9-12&#34;, &#34;12-15&#34;, &#34;15-18&#34;, &#34;18-21&#34;, &#34;21-24&#34;)
    ColumnTitles = list()
    
    for i in range(0, len(D.MLTsequence)):
        MLTfrom = int(D.MLTsequence[i])
        if MLTfrom &gt; 24: MLTfrom -=24
        MLTto = int(D.MLTsequence[i]+D.MLT_duration_of_a_bucket)
        if MLTto &gt; 24: MLTto -=24
        ColumnTitles.append( &#34;MLT &#34; + str(MLTfrom) + &#34;-&#34;  + str(MLTto) )
    # define secondary y-axis at the right of the plot
    mySpecs = list()
    for row in range(0, len(D.KPsequence)):
        mySpecs.append( list() )
        for col in range(0, len(D.MLTsequence)):
            mySpecs[row].append( {&#34;secondary_y&#34;: True} )

    #make plot
    if VariableName == &#34;Joule Heating&#34;: 
        XXtitle = &#39;Joule heating (10&lt;sup&gt;-8&lt;/sup&gt; W/m&lt;sup&gt;3&lt;/sup&gt;)&#39;
    elif VariableName == &#34;Pedersen Conductivity&#34;:
        XXtitle = &#39;Pedersen conductivity (mS/m)&#39;
    else:
        XXtitle = VariableName
    fig = make_subplots(rows=len(D.KPsequence), cols=len(D.MLTsequence), x_title=XXtitle, shared_xaxes=True, shared_yaxes=True, vertical_spacing=0.035, horizontal_spacing=0.02, subplot_titles=ColumnTitles, specs=mySpecs)
    
    fig.update_layout( font=dict( family=&#34;arial black&#34;, size=24 ) )
    fig.update_annotations( font=dict( family=&#34;arial black&#34;, size=24) )
    #fig.update_xaxes(title_font_family=&#34;Arial black&#34;, title_font_size=20)
    #fig.update_yaxes(title_font_family=&#34;Arial black&#34;, title_font_size=20)
    fig.update_xaxes(tickfont_size=22)
    fig.update_yaxes(tickfont_size=22)
    fig.layout.annotations[4][&#34;font&#34;] = {&#39;size&#39;: 30}  # this is the XXtitle at the bottom
    
    for aKP in D.KPsequence:
        for aMLT in D.MLTsequence:
            #Means = list()
            TIEGCMmedian = list()
            TIEGCMmedian2 = list()
            hits  = 0

            # compute TIEGCM 2ND RESULT percentiles
            if Buckets2 != None:
                TIEGCMarea_Upper = 0
                TIEGCMarea_Lower = 0
                TIEGCMarea2_Upper = 0
                TIEGCMarea2_Lower = 0
    
                for anALT in D.ALTsequence:
                    TIEGCMmedian2.append( Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor )
                #
                for anALT in D.ALTsequence:
                    if anALT &gt;= 120:
                        TIEGCMarea2_Upper += Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                    else:
                        TIEGCMarea2_Lower += Buckets2[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                # plot TIEGCM 2ND RESULT median
                if CurveColor==CurveColor2:
                    linetype = &#39;dot&#39;
                else:
                    linetype = &#39;solid&#39;
                fig.add_trace( go.Scatter(x=TIEGCMmedian2, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=None, line=dict(color=CurveColor,width=4,dash=linetype,), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1 )
                # CALCULATE the Height_integration-Vaue for TIEGCM 2ND RESULT= area under median curve
                TIEGCMarea2 = 0
                for i in range(0, len(TIEGCMmedian2)):
                    if math.isnan(TIEGCMmedian2[i]) == False: 
                        TIEGCMarea2 += TIEGCMmedian2[i]*D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;

            # compute TIEGCM percentiles
            for anALT in D.ALTsequence:
                TIEGCMmedian.append( Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor )
            #
            for anALT in D.ALTsequence:
                if anALT &gt;= 120:
                    TIEGCMarea_Upper += Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                else:
                    TIEGCMarea_Lower += Buckets[aKP, anALT, D.LAT_min, aMLT, &#34;Percentile50&#34;] * MultiplicationFactor * D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
            # plot TIEGCM median
            fig.add_trace( go.Scatter(x=TIEGCMmedian, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=None, line=dict(color=CurveColor,width=4,), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1 )
            
            # CALCULATE the Height_integration-Vaue for TIEGCM = area under median curve
            TIEGCMarea = 0
            for i in range(0, len(TIEGCMmedian)):
                if math.isnan(TIEGCMmedian[i]) == False: 
                    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName: 
                        TIEGCMarea += TIEGCMmedian[i]*D.ALT_distance_of_a_bucket * 0.01 # area*1000 * math.pow(10,-8) * 1000;
                    elif VariableName == &#34;Pedersen Conductivity&#34;:
                        TIEGCMarea += TIEGCMmedian[i]*D.ALT_distance_of_a_bucket # area*1000 * math.pow(10,-8) * 1000;

            # read the median curve of EISCAT
            [EISCATmedian, EISCATmedianTHIN] = getEISCAT_MedianCurve(VariableName, aKP, aMLT)
            
            # CALCULATE the Height_integration-Vaue for EISCAT = area under median curve
            EISCATarea = 0.0
            for i in range(0, len(EISCATmedian)):
                if math.isnan(EISCATmedian[i]) == False: 
                    if VariableName == &#34;Joule Heating&#34; or &#34;JH&#34; in VariableName: 
                        EISCATarea += EISCATmedian[i]*0.01  #area += EISCATmedian[i]*1000 * math.pow(10,-8) * 1000;
                    elif VariableName == &#34;Pedersen Conductivity&#34;:
                        EISCATarea += EISCATmedian[i]

            # Calculate the Percentage Difference
            try:
                SimilarityFactor_eiscat = (TIEGCMarea-EISCATarea) / ((TIEGCMarea+EISCATarea)/2)
                SimilarityFactor_eiscat = int(round(100*SimilarityFactor_eiscat,   0)) # %
            except:
                SimilarityFactor_eiscat = 0
            if Buckets2 != None:
                try:
                    SimilarityFactor_winds =  (TIEGCMarea2-TIEGCMarea) / TIEGCMarea 
                    SimilarityFactor_winds = int(round(100*SimilarityFactor_winds, 0)) # %    
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_ALL&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea/TIEGCMarea2,2) )
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_UPPER&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea_Upper/TIEGCMarea2_Upper ,2) )
                    #print ( &#34;HEIGHT_INTEGRATED_RATIO_LOWER&#34;, aMLT, aKP, &#34;\t&#34;, round(TIEGCMarea_Lower/TIEGCMarea2_Lower ,2) )
                    HEIGHT_INTEGRATED_RATIO_ALL_average += TIEGCMarea/TIEGCMarea2
                    HEIGHT_INTEGRATED_RATIO_UPPER_average += TIEGCMarea_Upper/TIEGCMarea2_Upper
                    HEIGHT_INTEGRATED_RATIO_LOWER_average += TIEGCMarea_Lower/TIEGCMarea2_Lower
                except:
                    pass
                #
                
            
                
            sim_factor_color = &#34;purple&#34;    

            # add annotations
            if VariableName==&#34;Joule Heating&#34;:
                if Buckets2 != None:
                    fig.add_annotation(xref=&#39;x domain&#39;, yref=&#39;y domain&#39;, x=0.99, y=1, text=F&#34;&lt;b&gt;{SimilarityFactor_winds}%&lt;/b&gt;&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=CurveColor) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=1, text=F&#34;{round(TIEGCMarea_Upper/TIEGCMarea2_Upper,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=0.5, text=F&#34;{round(TIEGCMarea/TIEGCMarea2,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                    #fig.add_annotation(xref=&#39;x domain&#39;,yref=&#39;y domain&#39;, x=0.5, y=0, text=F&#34;{round(TIEGCMarea_Lower/TIEGCMarea2_Lower,2)}&#34;, showarrow=False, row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, font=dict(color=&#39;black&#39;) )
                
                
            # add a trace in order to display secondary y-axis at the right
            fig.add_trace( go.Scatter(x=[-1000], y=[-1000], line=dict(color=CurveColor,width=1), showlegend=False), row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, secondary_y=True )
            
            
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    
    print ( &#34;HEIGHT_INTEGRATED_RATIO_ALL&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_ALL_average/12 ,2) )
    print ( &#34;HEIGHT_INTEGRATED_RATIO_UPPER&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_UPPER_average/12 ,2) )
    print ( &#34;HEIGHT_INTEGRATED_RATIO_LOWER&#34;, &#34;average&#34;, &#34;\t&#34;, round(HEIGHT_INTEGRATED_RATIO_LOWER_average/12 ,2) )
    
    fig.update_xaxes( range=x_axes_range, row=1, col=1)
    fig.update_xaxes( range=x_axes_range, row=1, col=2)
    fig.update_xaxes( range=x_axes_range, row=1, col=3)
    fig.update_xaxes( range=x_axes_range, row=1, col=4)
    
    fig.update_xaxes( range=x_axes_range, row=2, col=1)
    fig.update_xaxes( range=x_axes_range, row=2, col=2)
    fig.update_xaxes( range=x_axes_range, row=2, col=3)
    fig.update_xaxes( range=x_axes_range, row=2, col=4)
    
    fig.update_xaxes( range=x_axes_range, row=3, col=1)
    fig.update_xaxes( range=x_axes_range, row=3, col=2)
    fig.update_xaxes( range=x_axes_range, row=3, col=3)
    fig.update_xaxes( range=x_axes_range, row=3, col=4)
    
    for aKP in D.KPsequence:
        fig.update_yaxes( title_text=&#34;Altitude(km)&#34;, row=D.KPsequence.index(aKP)+1, col=1, side=&#39;left&#39;, secondary_y=False)
        row_title = &#34;Kp &#34; + str(aKP) + &#34; - &#34;
        if aKP == 0:
            row_title +=  &#34;2&#34;
        elif aKP == 2:
            row_title +=  &#34;4&#34;
        else:
            row_title +=  &#34;9&#34;
        fig.update_yaxes( title_text=row_title, row=D.KPsequence.index(aKP)+1, col=len(D.MLTsequence),  side=&#39;right&#39;, secondary_y=True, showticklabels=False )
        for aMLT in D.MLTsequence:
            fig.update_yaxes( row=D.KPsequence.index(aKP)+1, col=D.MLTsequence.index(aMLT)+1, secondary_y=True, showticklabels=False )
    #fig.update_xaxes( range=x_axes_range )
    fig.update_yaxes( range=[80, 150], tick0=90, dtick=20 )  
    fig.update_layout( title = SuperTitle,
                       width=400+len(D.MLTsequence)*250, height=200+200*len(D.KPsequence), showlegend=False, legend_orientation=&#34;h&#34;, legend_y=-0.04) 

    if Buckets2 == None:
        plotEISCAT( VariableName, fig )
    
    plotly.offline.init_notebook_mode(connected=True)
    plotly.offline.iplot(fig) 

    # plot more zoom versions
    &#39;&#39;&#39;
    new_x_axes_range = [x * (2/3) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (1/2) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (3/2) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (2.5) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    new_x_axes_range = [x * (10) for x in x_axes_range]
    fig.update_xaxes( range=new_x_axes_range )
    plotly.offline.iplot(fig) 
    &#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="TIEGCM_Statistics.Plotter_AltProfComparison.plotEISCAT"><code class="name flex">
<span>def <span class="ident">plotEISCAT</span></span>(<span>VariableName, fig)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds altitude profile curves of the median value of a variable as calculated by EISCAT</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>VariableName</code></strong> :&ensp;<code>string</code></dt>
<dd>The physical variable on which the calculation has been applied. </dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly object</code></dt>
<dd>the plotly figure upon which the EISCAT altitude profiles of the median value will be plotted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotEISCAT( VariableName, fig ):
    &#39;&#39;&#39;
    Adds altitude profile curves of the median value of a variable as calculated by EISCAT
    Args:
        VariableName (string): The physical variable on which the calculation has been applied. 
        fig (plotly object): the plotly figure upon which the EISCAT altitude profiles of the median value will be plotted.
    &#39;&#39;&#39;
    EISCATcolor = &#34;limegreen&#34;
    
    matlabStruct = scipy.io.loadmat(&#39;./EISCAT_DATA/data_2009_2019_TS.mat&#39;)
    
    allALTs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][0] ).flatten()
    allKPs  = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][1][0] ) )
    allMLTs = list( np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][2][0] )[:-1] )
    allJHs  = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][3] )
    allPEDs = np.array( matlabStruct[ &#39;data_2009_2019_TS&#39; ][0][0][4] )
    
    print(&#34;------------------ EISCAT info start ------------------&#34;)
    print( &#34;Altitudes:&#34;, allALTs[0], allALTs[1], &#34;...&#34;, allALTs[-1] )
    print( &#34;KPs:&#34;, allKPs  )
    print( &#34;MLTs:&#34;, allMLTs )
    print( &#34;JHs shape:&#34;, allJHs.shape )
    print( &#34;PEDs shape:&#34;, allPEDs.shape )    
    print(&#34;------------------ EISCAT info finish ------------------\n\n&#34;)
    
    if VariableName == &#34;Pedersen Conductivity&#34;:
        Values = allPEDs
        x_axes_range=[0, 0.4]
        MultiplicationFactor = 10**3 
        new_units = &#34;mS/m&#34;
    else:
        Values = allJHs
        x_axes_range=[0, 20]
        MultiplicationFactor = 10**8 
        new_units = &#34;10^-8 W/m3&#34;
    
    ALTsequence =  allALTs
    MLTsequence = allMLTs
    KPsequence = [ 0, 2, 4 ]  #list( mat_medians[ &#39;jouleMedians&#39; ][0][0][3] )
    MLT_duration_of_a_profile = 6
    
    # alter visibleALTsequence so that the point is displayed in the middle of the sub-bin
    visibleALTsequence = ALTsequence.copy()
    for i in range(1, len(visibleALTsequence)-1):
        visibleALTsequence[i] += 0.5
    
    for aKP in KPsequence:
        for aMLT in MLTsequence:
            #Means = list()
            EISCATmedian = list()            
            hits  = 0
            
            # compute percentiles
            EISCATmedian = Values[KPsequence.index(aKP), MLTsequence.index(aMLT), :, 2] * MultiplicationFactor #EISCATmedian = JHmedians[1,1,:] * MultiplicationFactor 

            fig.add_trace( go.Scatter(x=EISCATmedian, y=visibleALTsequence, mode=&#39;lines&#39;, fill=None, fillcolor=EISCATcolor, line=dict(color=EISCATcolor,width=4,), showlegend=False), row=KPsequence.index(aKP)+1, col=MLTsequence.index(aMLT)+1 )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TIEGCM_Statistics" href="index.html">TIEGCM_Statistics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="TIEGCM_Statistics.Plotter_AltProfComparison.getEISCAT_MedianCurve" href="#TIEGCM_Statistics.Plotter_AltProfComparison.getEISCAT_MedianCurve">getEISCAT_MedianCurve</a></code></li>
<li><code><a title="TIEGCM_Statistics.Plotter_AltProfComparison.plotAltProf_MedianComparison" href="#TIEGCM_Statistics.Plotter_AltProfComparison.plotAltProf_MedianComparison">plotAltProf_MedianComparison</a></code></li>
<li><code><a title="TIEGCM_Statistics.Plotter_AltProfComparison.plotEISCAT" href="#TIEGCM_Statistics.Plotter_AltProfComparison.plotEISCAT">plotEISCAT</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>